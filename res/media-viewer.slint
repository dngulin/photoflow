import { SpringConfig, SpringState, Spring } from "spring-animation.slint";
import { EveryFrameTimer } from "every-frame-timer.slint";
import { GamepadKey } from "gamepad.slint";

export enum ViewerState {
    Loading,
    Loaded,
    FailedToLoad
}

export struct MediaViewerModel {
    state: ViewerState,
    file-name: string,
    image: image,
    is-video: bool,
    video-is-playing: bool,
    video-progress: float,
}

enum SeekDirection {
    Backward,
    Forward
}

export component MediaViewer inherits Rectangle {
    width: 100%;
    height: 100%;
    clip: true;

    in property <MediaViewerModel> model;

    forward-focus: fs;
    in-out property <bool> enabled: true;

    callback next();
    callback prev();
    callback exit();

    pure callback poll-video-state();
    callback video-set-playing(playing-state: bool);
    callback video-seek-progress(progress: float);

    if model.state != ViewerState.FailedToLoad: Image {
        width: 100%;
        height: 100%;
        image-fit: contain;
        source: model.image;
    }

    private property <bool> video-active: model.is-video && model.state == ViewerState.Loaded;
    changed video-active => {
        seeking.active = false;
    }

    if video-active: Rectangle {
        width: parent.width;
        height: 4px;
        x: 0;
        y: parent.height - self.height;

        private property <float> progress: seeking.active ? seeking.target : model.video-progress;

        Rectangle {
            x: 0;
            y: 0;
            height: parent.height;
            width: progress * parent.width;
            background: white;
        }

        visible: self.is-visible();
        pure function is-visible() -> bool {
            poll-video-state();
            true
        }
    }

    spinner := Image {
        x: parent.width - self.width;
        y: parent.height - self.height;
        source: @image-url("img/spinner.svg");
        rotation-angle: 360deg * mod(animation-tick(), 2s) / 2s;

        property <float> traget-opacity: model.state == ViewerState.Loading ? 1 : 0;
        changed traget-opacity => {
            spinner-alpha-animator.start();
        }
    }

    spinner-alpha-animator := EveryFrameTimer {
        active: Spring.is-active(state);

        private property <SpringState> state: { current-value: spinner.traget-opacity, target-value: spinner.traget-opacity };
        private property <SpringConfig> config: { stiffness: 500, damping: 40, mass: 1 };

        function start() {
            state = Spring.start(spinner.opacity, spinner.traget-opacity, state.velocity);
        }

        triggered(dt) => {
            state = Spring.update(config, state, dt / 1s);
            spinner.opacity = state.current-value;
        }
    }

    if model.state == ViewerState.FailedToLoad: Text {
        text: model.file-name;
        color: white;
        vertical-alignment: center;
        horizontal-alignment: center;
    }

    fs := FocusScope {
        enabled: parent.enabled;
        key-pressed(event) => {
            if (!self.enabled) {
                reject
            }
            if (event.text == GamepadKey.DPadRight) {
                if (model.state != ViewerState.Loading) {
                    next();
                }
                accept
            } else if (event.text == GamepadKey.DPadLeft) {
                if (model.state != ViewerState.Loading) {
                    prev();
                }
                accept
            } else if (event.text == GamepadKey.ActDown) {
                if (video-active && !seeking.active && !event.repeat) {
                    video-set-playing(!model.video-is-playing);
                }
                accept
            } else if (event.text == GamepadKey.TriggerL2 || event.text == GamepadKey.TriggerR2) {
                if (video-active && !event.repeat) {
                    seeking.start(event.text == GamepadKey.TriggerL2 ? SeekDirection.Backward : SeekDirection.Forward);
                }
                accept
            } else if (event.text == GamepadKey.ActRight) {
                exit();
                accept
            }
            reject
        }

        key-released(event) => {
            if (!self.enabled) {
                reject
            }
            if (event.text == GamepadKey.TriggerL2 || event.text == GamepadKey.TriggerR2) {
                seeking.try-finish(event.text == GamepadKey.TriggerL2 ? SeekDirection.Backward : SeekDirection.Forward);
                accept
            }
            reject
        }
    }

    seeking := EveryFrameTimer {
        active: false;

        private property <SeekDirection> direction;
        private property <bool> was-playing;
        out property <float> target;

        public function start(direction: SeekDirection) {
            self.direction = direction;
            self.active = true;
            self.target = model.video-progress;

            self.was-playing = model.video-is-playing;
            if (model.video-is-playing) {
                video-set-playing(false);
            }
        }

        public function finish() {
            self.active = false;
            if (self.was-playing) {
                video-set-playing(true);
            }
        }

        public function try-finish(direction: SeekDirection) {
            if (direction == self.direction) {
                self.finish();
            }
        }

        pure function velocity() -> float {
            self.direction == SeekDirection.Forward ? 0.1 : -0.1;
        }

        pure function progress-delta(dt: duration) -> float {
            (dt / 1s) * self.velocity()
        }

        triggered(dt) => {
            self.target = clamp(self.target + self.progress-delta(dt), 0, 1);
            video-seek-progress(self.target);
        }
    }
}

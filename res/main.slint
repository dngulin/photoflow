export struct ViewModelItem {
    index: int,
    image: image,
}

component VerticalScrollable inherits Rectangle {
    width: 100%;
    height: 100%;
    clip: true;

    in property <length> contents-w;
    in property <length> contents-h;

    in-out property <length> viewport-x;
    in-out property <length> viewport-y;

    in property <float> spring-scroll-stiffness: 700;
    in property <float> spring-scroll-damping: 40;
    in property <float> spring-scroll-mass: 1;

    public function set-spring-scroll-target(target: length) {
        spring.tgt-value = target;
        spring.running = true;
    }

    Rectangle {
        x: -root.viewport-x;
        y: -root.viewport-y;
        width: root.contents-w;
        height: root.contents-h;
        @children
    }

    spring := Timer {
        interval: 1s / 60;
        running: false;

        in property <float> stiffness: root.spring-scroll-stiffness;
        in property <float> damping: root.spring-scroll-damping;
        in property <float> mass: root.spring-scroll-mass;

        property <length> tgt-value;

        property <length> displacement: root.viewport-y - self.tgt-value;
        property <float> stiffness-force: -displacement / 1px * stiffness;

        property <float> velocity: 0;
        property <float> damping-force: -velocity * damping;

        property <float> dt: self.interval / 1s;

        triggered => {
            self.velocity += (self.stiffness-force + self.damping-force) / self.mass * dt;
            root.viewport-y += self.velocity * dt * 1px;

            if (displacement < 1phx && abs(self.velocity * dt) < 0.1) {
                self.velocity = 0;
                root.viewport-y = self.tgt-value;
                self.running = false;
            }
        }
    }
}

component ImageGrid inherits VerticalScrollable {
    // Visual config
    in property <length> img-size: 235px;
    in property <length> img-pad-size: 2px;

    // Model setup
    in property <int> item-count: 0;
    in property <[ViewModelItem]> view-model;
    pure callback set-view-model-range(int, int) -> bool;

    // Hack to auto-synchronise view-model range
    in property <bool> is-visible: true;
    visible: visibility-hook(is-visible);

    pure function visibility-hook(value: bool) -> bool {
        if (value) {
            set-view-model-range(model-offset, model-length);
        }
        value
    }

    // Item size
    property <length> item-size: self.img-size + 2 * self.img-pad-size;

    // Rows & cols
    property <int> cols: min(floor(self.width / self.item-size), self.item-count);
    property <int> rows: cols == 0 ? 0 : ceil(self.item-count / self.cols);

    // Contents
    contents-w: self.width;
    contents-h: item-size * rows;

    // View Model Items & Selection Indicator
    out property <int> selected-idx: 0;

    Rectangle {
        width: root.item-size * root.cols;
        height: root.item-size * root.rows;
        x: (root.width - self.width) * 0.5;

        for item in root.view-model: Rectangle {
            width: root.item-size;
            height: root.item-size;
            x: root.item-pos-x(item.index);
            y: root.item-pos-y(item.index);
            Image {
                width: root.img-size;
                height: root.img-size;
                x: root.img-pad-size;
                y: root.img-pad-size;
                source: item.image;
            }
        }

        Rectangle {
            visible: root.item-count > 0;
            width: root.item-size;
            height: root.item-size;
            x: root.item-pos-x(root.selected-idx);
            y: root.item-pos-y(root.selected-idx);
            border-width: root.img-pad-size;
            border-color: white;
        }
    }

    pure function item-col(index: int) -> int {
        mod(index, cols)
    }

    pure function item-row(index: int) -> int {
        floor(index / cols)
    }

    pure function item-pos-x(index: int) -> length {
        item-col(index) * item-size
    }

    pure function item-pos-y(index: int) -> length {
        item-row(index) * item-size
    }

    // Move selection API
    public function mv-selection-right() {
        if (selected-idx < item-count - 1 && item-col(selected-idx + 1) > item-col(selected-idx)) {
            selected-idx += 1;
        }
    }

    public function mv-selection-left() {
        if (selected-idx > 0 && item-col(selected-idx - 1) < item-col(selected-idx)) {
            selected-idx -= 1;
        }
    }

    public function mv-selection-up() {
        if (selected-idx - cols >= 0) {
            selected-idx -= cols;
            update-scrolling-spring();
        }
    }

    public function mv-selection-down() {
        if (selected-idx + cols < item-count) {
            selected-idx += cols;
            update-scrolling-spring();
        }
    }

    // Viewport Scrolling
    property <length> viewport-start: self.viewport-y;
    property <length> viewport-end: self.viewport-start + self.height;

    property <length> curr-item-start: item-pos-y(selected-idx);
    property <length> curr-item-end: self.curr-item-start + item-size;

    function update-scrolling-spring() {
        if (self.viewport-start > self.curr-item-start) {
            self.set-spring-scroll-target(self.curr-item-start);
        } else if (self.viewport-end < self.curr-item-end) {
            self.set-spring-scroll-target(curr-item-end - self.height);
        }
    }

    // Visible Range Reporting
    property <int> min-visible-row: floor(self.viewport-start / item-size);
    property <int> max-visible-row: ceil(self.viewport-end / item-size);

    property <int> model-offset: clamp(min-visible-row * cols, 0, max(item-count - 1, 0));
    property <int> model-length: clamp(max-visible-row * cols - model-offset, 0, max(item-count - model-offset, 0));
}

export component PhotoFlowApp inherits Window {
    background: black;
    forward-focus: focus-scope;

    in property <int> item-count <=> grid.item-count;
    in property <[ViewModelItem]> view-model <=> grid.view-model;
    pure callback set-view-model-range <=> grid.set-view-model-range;

    grid := ImageGrid { }

    focus-scope := FocusScope {
        key-pressed(event) => {
            if (event.text == Key.RightArrow) {
                grid.mv-selection-right();
            } else if (event.text == Key.LeftArrow) {
                grid.mv-selection-left();
            } else if (event.text == Key.UpArrow) {
                grid.mv-selection-up();
            } else if (event.text == Key.DownArrow) {
                grid.mv-selection-down();
            }
            accept
        }
    }
}
